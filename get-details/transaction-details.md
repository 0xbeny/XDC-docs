# Transaction Details

## What is a Transaction

A transaction is a cryptographically signed instruction initiated by an externally owned account. Once executed, the state of the XDC network is updated. The simplest transaction involves transferring XDC from one account to another. For example, if Ben sends Ana 1 XDC, his account will be debited, and Ana's will be credited 1 XDC. Both of these state-changing actions occur in the space of a single transaction.

Transactions are broadcast by nodes to the entire network to be executed on the virtual machine. A validator will execute the transaction and circulate the resulting state change to the entire network.

A submitted transaction consists of the following details:

* `signature`: The sender's identifier, generated by signing the transaction with the sender's private key that confirms its authorization.
* `recipient`: The receiving address. The transaction will transfer value for an externally owned account. However, for a contract account, it will execute the contract code.
* `value`: The amount of XDC to transfer from sender to recipient.
* `data`: An optional field that allows the inclusion of arbitrary data.
* `gasPrice`: The fee charged per unit of gas.
* `gasLimit`: The maximum amount of gas units that the transaction can consume. Units of gas represent computational steps.

Gas is the reference to the computational power required for a validator to execute the transaction. Users will have to pay a fee for this computation. The `gasPrice` and `gasLimit` determine the maximum transaction fee paid to the validator.

The transaction object looks like this:

```
{
  from: "0xEA674fdDe714fd879de3EdF0F56AA9516B898ec8",
  to: "0xac03bb73b6a9e108530aff4ef5077c2b3d481e5a",
  gasLimit: "35000",
  gasPrice: "200",
  nonce: "0",
  value: "10000000000",
  }
  
```

A transaction object is signed using the sender’s private key, ensuring that the transaction arrived from the authorized sender and was not sent fraudulently.

### **Example of a Transaction**

It is necessary to have the private key associated with the sender’s address to transfer XDC from one account to another:

```
let account = try! XDCAccount.init(keyStorage: XDCPrivateKeyStore(privateKey: "0x2b6dbb667da5962bb96fe9ae87c53a5308afeabb6f6be0be2d5f27be2efcf4d"))
```

We need to create an instance of XDCTransaction with values we want to send to the account.

```
let tx = XDCTransaction(from: nil, to: XDCAddress(xdcAddress), value: BigUInt(d3), data: nil, nonce: 3, gasPrice: BigUInt(4000004), gasLimit: BigUInt(50005), chainId: 51)
```

Now, we need to call the eth\_sendRawTransaction method.

```
client.eth_sendRawTransaction(tx, withAccount: self.account!) { (err, tx) in
     print(tx ?? "no tx")     

```

We will receive one txHash, which will include all data of the transaction.

#### Response:

```
     {
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "blockHash": "0x4c5464098a8cc253157f3bba0e8f2d626691b1eb22e4465de8b8644b23b8ad76",
    "blockNumber": "0x1496de7",
    "from": "xdc6ffe09f9302a857fcb122296e3ab3bb80c45cbcd",
    "gas": "0xc355",
    "gasPrice": "0x3d0904",
    "hash": "0x903d735683c2959b86aea197a06583a30837b4a505465a0da2347f61d6daa533",
    "input": "0x",
    "nonce": "0x150",
    "to": "xdcd7813e7cfdf83d6fa3469d7411b52a50ed2b867f",
    "transactionIndex": "0x0",
    "value": "0x6124fee993bc0000",
    "v": "0x8a",
    "r": "0xaad835079b2b4753af3fba7f6423594154f3d05677b1db868dd4345009b80a31",
    "s": "0x62cc01a1c4135286e28ba8fbf91b4c9e74c015d82be352310a11d1e0eb411148"
  }
}
```

The transaction’s signature hash is cryptographically proven, verifying that it came from the legitimate sender.

### **Gas**

As already mentioned, transactions cost gas to process. Simple transfer transactions may require 35000 units of gas.

So, for Ben to send Ana 1 XDC at a `gasPrice` of 30 gwei, Ben will need to pay the following fee:

`30 * 35000 = 1,050,000 gwei`

`--or--`

`0.00105 XDC`

Ben's account is debited **-1.00105 XDC**

Ana's account is credited **+1.0 XDC**

The validator processing the transaction gets **+0.00105 XDC**

Gas is also required for smart contract interactions.

Gas is refunded to the user's account if it is not used in any transaction.

### Transaction Life Cycle

Once the transaction is submitted, the following occurs:

1. After sending a transaction, cryptography generates a transaction hash, such as`0x903d735683c2959b86aea197a06583a30837b4a505465a0da2347f61d6daa533`
2. The transaction is then streamed to the network and included in the pool of transactions.
3. A validator must pick the transaction and include it in a block to verify it and consider it successful. If the network is busy and validators cannot keep up, there may be a delay. Since validators get the fees, they will always prioritize transactions with higher `gasPrice`.
4. The transaction will get a block confirmation number. It is the number of blocks created since the transaction's block was first included. A higher number provides a certainty that the network has successfully executed and recognized the transaction. A higher block confirmation number thus ensures the immutability of the transaction.
